"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   G: () => (/* binding */ GainMapNotFoundError),\n/* harmony export */   L: () => (/* binding */ LoaderBaseShared),\n/* harmony export */   M: () => (/* binding */ MPFExtractor),\n/* harmony export */   X: () => (/* binding */ XMPMetadataNotFoundError),\n/* harmony export */   a: () => (/* binding */ extractXMP),\n/* harmony export */   c: () => (/* binding */ createDecodeFunction),\n/* harmony export */   e: () => (/* binding */ extractGainmapFromJPEG)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */\n\n\n\n/**\n * Shared decode implementation factory\n * Creates a decode function that prepares a QuadRenderer with the given parameters\n */\nfunction createDecodeFunction(config) {\n    return (params) => {\n        const { sdr, gainMap, renderer } = params;\n        if (sdr.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n            console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n            sdr.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        }\n        sdr.needsUpdate = true;\n        if (gainMap.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace) {\n            console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n            gainMap.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n        }\n        gainMap.needsUpdate = true;\n        const material = config.createMaterial({\n            ...params,\n            sdr,\n            gainMap\n        });\n        const quadRenderer = config.createQuadRenderer({\n            width: sdr.image.width,\n            height: sdr.image.height,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer,\n            renderTargetOptions: params.renderTargetOptions\n        });\n        return quadRenderer;\n    };\n}\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getXMLValue = (xml, tag, defaultValue) => {\n    // Check for attribute format first: tag=\"value\"\n    const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n    if (attributeMatch)\n        return attributeMatch[1];\n    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n    const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n    if (tagMatch) {\n        // Check if it contains rdf:li elements\n        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n        if (liValues && liValues.length === 3) {\n            return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n        }\n        return tagMatch[1].trim();\n    }\n    if (defaultValue !== undefined)\n        return defaultValue;\n    throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = (input) => {\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n            const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n            const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n            // These are always attributes, so we can use a simpler regex\n            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n            if (!hdrCapacityMaxMatch)\n                throw new Error('Incomplete gainmap metadata');\n            const hdrCapacityMax = hdrCapacityMaxMatch[1];\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n            // Continue searching for another xmpmeta block if this one fails\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    options;\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops üòµ`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\n/**\n * Shared base class for loaders that extracts common logic\n */\nclass LoaderBaseShared extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    _renderer;\n    _renderTargetOptions;\n    _internalLoadingManager;\n    _config;\n    constructor(config, manager) {\n        super(manager);\n        this._config = config;\n        if (config.renderer)\n            this._renderer = config.renderer;\n        this._internalLoadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    }\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    prepareQuadRenderer() {\n        if (!this._renderer) {\n            console.warn('WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        }\n        const material = this._config.createMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new three__WEBPACK_IMPORTED_MODULE_0__.Texture(),\n            sdr: new three__WEBPACK_IMPORTED_MODULE_0__.Texture()\n        });\n        return this._config.createQuadRenderer({\n            width: 16,\n            height: 16,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    async processImages(sdrBuffer, gainMapBuffer, imageOrientation) {\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = imageOrientation === 'flipY';\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: imageOrientation || 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: imageOrientation || 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        return { sdrImage, gainMapImage, needsFlip };\n    }\n    createTextures(sdrImage, gainMapImage, needsFlip) {\n        const gainMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(gainMapImage || new ImageData(2, 2), three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(sdrImage, three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        return { gainMap, sdr };\n    }\n    updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9Mb2FkZXItRExJLV9KRFAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbU47O0FBRW5OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekMsK0JBQStCLGlEQUFjO0FBQzdDO0FBQ0EsNkJBQTZCLGlEQUFjO0FBQzNDO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQW9CO0FBQ3ZEO0FBQ0EsaUNBQWlDLHVEQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFhO0FBQy9CLHdCQUF3Qix1REFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJLHNCQUFzQixJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxvQkFBb0IsYUFBYSx1Q0FBdUM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsdURBQXVELDRDQUE0QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVDQUF1QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaURBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQU87QUFDaEMscUJBQXFCLDBDQUFPO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQWE7QUFDL0Isd0JBQXdCLHVEQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdFQUF3RSxvQkFBb0I7QUFDNUYsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELCtDQUErQztBQUM5Ryw2Q0FBNkMsK0NBQStDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0QkFBNEIsMENBQU8sc0NBQXNDLDRDQUFTLEVBQUUsc0RBQW1CLEVBQUUsc0RBQW1CLEVBQUUsK0NBQVksRUFBRSwyREFBd0IsRUFBRSw2Q0FBVSxFQUFFLG1EQUFnQixLQUFLLHVEQUFvQjtBQUMzTjtBQUNBO0FBQ0Esd0JBQXdCLDBDQUFPLFdBQVcsNENBQVMsRUFBRSxzREFBbUIsRUFBRSxzREFBbUIsRUFBRSwrQ0FBWSxFQUFFLDJEQUF3QixFQUFFLDZDQUFVLEVBQUUsbURBQWdCLEtBQUssaURBQWM7QUFDdEw7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1TCIsInNvdXJjZXMiOlsid2VicGFjazovL2FycXByZW1pLy4vbm9kZV9tb2R1bGVzL0Btb25vZ3JpZC9nYWlubWFwLWpzL2Rpc3QvTG9hZGVyLURMSS1fSkRQLmpzPzUyODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9ub2dyaWQvZ2Fpbm1hcC1qcyB2My40LjBcbiAqIFdpdGgg4p2k77iPLCBieSBNT05PR1JJRCA8Z2Fpbm1hcEBtb25vZ3JpZC5jb20+XG4gKi9cblxuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UsIExpbmVhclNSR0JDb2xvclNwYWNlLCBIYWxmRmxvYXRUeXBlLCBMb2FkZXIsIExvYWRpbmdNYW5hZ2VyLCBUZXh0dXJlLCBVVk1hcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBSR0JBRm9ybWF0LCBVbnNpZ25lZEJ5dGVUeXBlIH0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIFNoYXJlZCBkZWNvZGUgaW1wbGVtZW50YXRpb24gZmFjdG9yeVxuICogQ3JlYXRlcyBhIGRlY29kZSBmdW5jdGlvbiB0aGF0IHByZXBhcmVzIGEgUXVhZFJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVjb2RlRnVuY3Rpb24oY29uZmlnKSB7XG4gICAgcmV0dXJuIChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZHIsIGdhaW5NYXAsIHJlbmRlcmVyIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChzZHIuY29sb3JTcGFjZSAhPT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU0RSIENvbG9yc3BhY2UgbmVlZHMgdG8gYmUgKlNSR0JDb2xvclNwYWNlKiwgc2V0dGluZyBpdCBhdXRvbWF0aWNhbGx5Jyk7XG4gICAgICAgICAgICBzZHIuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIHNkci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGlmIChnYWluTWFwLmNvbG9yU3BhY2UgIT09IExpbmVhclNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dhaW5tYXAgQ29sb3JzcGFjZSBuZWVkcyB0byBiZSAqTGluZWFyU1JHQkNvbG9yU3BhY2UqLCBzZXR0aW5nIGl0IGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgICAgIGdhaW5NYXAuY29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGdhaW5NYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IGNvbmZpZy5jcmVhdGVNYXRlcmlhbCh7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBzZHIsXG4gICAgICAgICAgICBnYWluTWFwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSBjb25maWcuY3JlYXRlUXVhZFJlbmRlcmVyKHtcbiAgICAgICAgICAgIHdpZHRoOiBzZHIuaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNkci5pbWFnZS5oZWlnaHQsXG4gICAgICAgICAgICB0eXBlOiBIYWxmRmxvYXRUeXBlLFxuICAgICAgICAgICAgY29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0T3B0aW9uczogcGFyYW1zLnJlbmRlclRhcmdldE9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgfTtcbn1cblxuY2xhc3MgR2Fpbk1hcE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmNsYXNzIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cblxuY29uc3QgZ2V0WE1MVmFsdWUgPSAoeG1sLCB0YWcsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIC8vIENoZWNrIGZvciBhdHRyaWJ1dGUgZm9ybWF0IGZpcnN0OiB0YWc9XCJ2YWx1ZVwiXG4gICAgY29uc3QgYXR0cmlidXRlTWF0Y2ggPSBuZXcgUmVnRXhwKGAke3RhZ309XCIoW15cIl0qKVwiYCwgJ2knKS5leGVjKHhtbCk7XG4gICAgaWYgKGF0dHJpYnV0ZU1hdGNoKVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlTWF0Y2hbMV07XG4gICAgLy8gQ2hlY2sgZm9yIHRhZyBmb3JtYXQ6IDx0YWc+dmFsdWU8L3RhZz4gb3IgPHRhZz48cmRmOmxpPnZhbHVlPC9yZGY6bGk+Li4uPC90YWc+XG4gICAgY29uc3QgdGFnTWF0Y2ggPSBuZXcgUmVnRXhwKGA8JHt0YWd9W14+XSo+KFtcXFxcc1xcXFxTXSo/KTwvJHt0YWd9PmAsICdpJykuZXhlYyh4bWwpO1xuICAgIGlmICh0YWdNYXRjaCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjb250YWlucyByZGY6bGkgZWxlbWVudHNcbiAgICAgICAgY29uc3QgbGlWYWx1ZXMgPSB0YWdNYXRjaFsxXS5tYXRjaCgvPHJkZjpsaT4oW148XSopPFxcL3JkZjpsaT4vZyk7XG4gICAgICAgIGlmIChsaVZhbHVlcyAmJiBsaVZhbHVlcy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBsaVZhbHVlcy5tYXAodiA9PiB2LnJlcGxhY2UoLzxcXC8/cmRmOmxpPi9nLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWdNYXRjaFsxXS50cmltKCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgJHt0YWd9IGluIGdhaW5tYXAgbWV0YWRhdGFgKTtcbn07XG5jb25zdCBleHRyYWN0WE1QID0gKGlucHV0KSA9PiB7XG4gICAgbGV0IHN0cjtcbiAgICAvLyBzdXBwb3J0IG5vZGUgdGVzdCBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBzdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaW5wdXQpO1xuICAgIGVsc2VcbiAgICAgICAgc3RyID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICBsZXQgc3RhcnQgPSBzdHIuaW5kZXhPZignPHg6eG1wbWV0YScpO1xuICAgIHdoaWxlIChzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgZW5kID0gc3RyLmluZGV4T2YoJ3g6eG1wbWV0YT4nLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IHhtcEJsb2NrID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnYWluTWFwTWluID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpHYWluTWFwTWluJywgJzAnKTtcbiAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBNYXggPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOkdhaW5NYXBNYXgnKTtcbiAgICAgICAgICAgIGNvbnN0IGdhbW1hID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpHYW1tYScsICcxJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRTRFIgPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOk9mZnNldFNEUicsICcwLjAxNTYyNScpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SERSID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpPZmZzZXRIRFInLCAnMC4wMTU2MjUnKTtcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBhbHdheXMgYXR0cmlidXRlcywgc28gd2UgY2FuIHVzZSBhIHNpbXBsZXIgcmVnZXhcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWluTWF0Y2ggPSAvaGRyZ206SERSQ2FwYWNpdHlNaW49XCIoW15cIl0qKVwiLy5leGVjKHhtcEJsb2NrKTtcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWluID0gaGRyQ2FwYWNpdHlNaW5NYXRjaCA/IGhkckNhcGFjaXR5TWluTWF0Y2hbMV0gOiAnMCc7XG4gICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1heE1hdGNoID0gL2hkcmdtOkhEUkNhcGFjaXR5TWF4PVwiKFteXCJdKilcIi8uZXhlYyh4bXBCbG9jayk7XG4gICAgICAgICAgICBpZiAoIWhkckNhcGFjaXR5TWF4TWF0Y2gpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIGdhaW5tYXAgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWF4ID0gaGRyQ2FwYWNpdHlNYXhNYXRjaFsxXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogQXJyYXkuaXNBcnJheShnYWluTWFwTWluKSA/IGdhaW5NYXBNaW4ubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYWluTWFwTWluKSwgcGFyc2VGbG9hdChnYWluTWFwTWluKSwgcGFyc2VGbG9hdChnYWluTWFwTWluKV0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1heDogQXJyYXkuaXNBcnJheShnYWluTWFwTWF4KSA/IGdhaW5NYXBNYXgubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYWluTWFwTWF4KSwgcGFyc2VGbG9hdChnYWluTWFwTWF4KSwgcGFyc2VGbG9hdChnYWluTWFwTWF4KV0sXG4gICAgICAgICAgICAgICAgZ2FtbWE6IEFycmF5LmlzQXJyYXkoZ2FtbWEpID8gZ2FtbWEubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYW1tYSksIHBhcnNlRmxvYXQoZ2FtbWEpLCBwYXJzZUZsb2F0KGdhbW1hKV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiBBcnJheS5pc0FycmF5KG9mZnNldFNEUikgPyBvZmZzZXRTRFIubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChvZmZzZXRTRFIpLCBwYXJzZUZsb2F0KG9mZnNldFNEUiksIHBhcnNlRmxvYXQob2Zmc2V0U0RSKV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiBBcnJheS5pc0FycmF5KG9mZnNldEhEUikgPyBvZmZzZXRIRFIubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChvZmZzZXRIRFIpLCBwYXJzZUZsb2F0KG9mZnNldEhEUiksIHBhcnNlRmxvYXQob2Zmc2V0SERSKV0sXG4gICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW46IHBhcnNlRmxvYXQoaGRyQ2FwYWNpdHlNaW4pLFxuICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiBwYXJzZUZsb2F0KGhkckNhcGFjaXR5TWF4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gQ29udGludWUgc2VhcmNoaW5nIGZvciBhbm90aGVyIHhtcG1ldGEgYmxvY2sgaWYgdGhpcyBvbmUgZmFpbHNcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0ci5pbmRleE9mKCc8eDp4bXBtZXRhJywgZW5kKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1QRiBFeHRyYWN0b3IgKE11bHRpIFBpY3R1cmUgRm9ybWF0IEV4dHJhY3RvcilcbiAqIEJ5IEhlbnJpayBTIE5pbHNzb24gMjAxOVxuICpcbiAqIEV4dHJhY3RzIGltYWdlcyBzdG9yZWQgaW4gaW1hZ2VzIGJhc2VkIG9uIHRoZSBNUEYgZm9ybWF0IChmb3VuZCBoZXJlOiBodHRwczovL3d3dy5jaXBhLmpwL2Uvc3RkL3N0ZC1zZWMuaHRtbFxuICogdW5kZXIgXCJDSVBBIERDLTAwNy1UcmFuc2xhdGlvbi0yMDIxIE11bHRpLVBpY3R1cmUgRm9ybWF0XCJcbiAqXG4gKiBPdmVybHkgY29tbWVudGVkLCBhbmQgd2l0aG91dCBpbnRlbnRpb24gb2YgYmVpbmcgY29tcGxldGUgb3IgcHJvZHVjdGlvbiByZWFkeS5cbiAqIENyZWF0ZWQgdG8gZXh0cmFjdCBkZXB0aCBtYXBzIGZyb20gaVBob25lIGltYWdlcywgYW5kIHRvIGxlYXJuIGFib3V0IGltYWdlIG1ldGFkYXRhLlxuICogS3Vkb3MgdG86IFBoaWwgSGFydmV5IChleGlmdG9vbCksIEphdW1lIFNhbmNoZXogKGFuZHJvaWQtbGVucy1ibHVyLWRlcHRoLWV4dHJhY3RvcilcbiAqL1xuY2xhc3MgTVBGRXh0cmFjdG9yIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgZGVidWc6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWJ1ZyA6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFjdEZJSTogb3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhY3RGSUkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cmFjdEZJSSA6IHRydWUsXG4gICAgICAgICAgICBleHRyYWN0Tm9uRklJOiBvcHRpb25zICYmIG9wdGlvbnMuZXh0cmFjdE5vbkZJSSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRyYWN0Tm9uRklJIDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBleHRyYWN0KGltYWdlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnID0gdGhpcy5vcHRpb25zLmRlYnVnO1xuICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoaW1hZ2VBcnJheUJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgLy8gSWYgeW91J3JlIGV4ZWN1dGluZyB0aGlzIGxpbmUgb24gYSBiaWcgZW5kaWFuIG1hY2hpbmUsIGl0J2xsIGJlIHJldmVyc2VkLlxuICAgICAgICAgICAgLy8gYmlnRW5kIGZ1cnRoZXIgZG93biB0aG91Z2gsIHJlZmVycyB0byB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaW1hZ2UgaXRzZWxmLlxuICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNigwKSAhPT0gMHhmZmQ4KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IGEgdmFsaWQganBlZycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgICAgICBsZXQgbG9vcHMgPSAwO1xuICAgICAgICAgICAgbGV0IG1hcmtlcjsgLy8gQVBQIyBtYXJrZXJcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytsb29wcyA+IDI1MCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGb3VuZCBubyBtYXJrZXIgYWZ0ZXIgJHtsb29wc30gbG9vcHMg8J+YtWApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBOb3QgYSB2YWxpZCBtYXJrZXIgYXQgb2Zmc2V0IDB4JHtvZmZzZXQudG9TdHJpbmcoMTYpfSwgZm91bmQ6IDB4JHtkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpLnRvU3RyaW5nKDE2KX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFya2VyOiAke21hcmtlci50b1N0cmluZygxNil9YCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlciA9PT0gMHhlMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgQVBQMiBtYXJrZXIgKDB4ZmZlMiknKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya3MgZm9yIGlQaG9uZSA4IFBsdXMsIFgsIGFuZCBYU01heC4gT3IgYW55IHBob3RvcyBvZiBNUEYgZm9ybWF0LlxuICAgICAgICAgICAgICAgICAgICAvLyBHcmVhdCB3YXkgdG8gdmlzdWFsaXplIGltYWdlIGluZm9ybWF0aW9uIGluIGh0bWwgaXMgdXNpbmcgRXhpZnRvb2wuIEUuZy46XG4gICAgICAgICAgICAgICAgICAgIC8vIC4vZXhpZnRvb2wuZXhlIC1odG1sZHVtcCAtd2FudFRyYWlsZXIgcGhvdG8uanBnID4gcGhvdG8uaHRtbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXRQdCA9IG9mZnNldCArIDQ7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqICBTdHJ1Y3R1cmUgb2YgdGhlIE1QIEZvcm1hdCBJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqICBPZmZzZXQgQWRkci4gIHwgQ29kZSAoSGV4KSAgfCBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiAgKzAwICAgICAgICAgICAgIGZmICAgICAgICAgICAgTWFya2VyIFByZWZpeCAgICAgIDwtLSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICogICswMSAgICAgICAgICAgICBlMiAgICAgICAgICAgIEFQUDJcbiAgICAgICAgICAgICAgICAgICAgICogICswMiAgICAgICAgICAgICAjbiAgICAgICAgICAgIEFQUDIgRmllbGQgTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAqICArMDMgICAgICAgICAgICAgI24gICAgICAgICAgICBBUFAyIEZpZWxkIExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzA0ICAgICAgICAgICAgIDRkICAgICAgICAgICAgJ00nICAgICAgICAgICAgICAgIDwtLSBmb3JtYXRQdFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzA1ICAgICAgICAgICAgIDUwICAgICAgICAgICAgJ1AnXG4gICAgICAgICAgICAgICAgICAgICAqICArMDYgICAgICAgICAgICAgNDYgICAgICAgICAgICAnRidcbiAgICAgICAgICAgICAgICAgICAgICogICswNyAgICAgICAgICAgICAwMCAgICAgICAgICAgIE5VTExcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gdGlmZk9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQzMihmb3JtYXRQdCkgPT09IDB4NGQ1MDQ2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIE1QRiB0YWcsIHNvIHdlIHN0YXJ0IGRpZyBvdXQgc3ViIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlmZk9mZnNldCA9IGZvcm1hdFB0ICsgNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaWdFbmQ7IC8vIEVuZGlhbm5lc3MgZnJvbSBUSUZGIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBmb3IgVElGRiB2YWxpZGl0eSBhbmQgZW5kaWFubmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHg0OTQ5IGFuZCAweDRENEQgKCdJSScgYW5kICdNTScpIG1hcmtzIExpdHRsZSBFbmRpYW4gYW5kIEJpZyBFbmRpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NDk0OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDRkNGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm8gdmFsaWQgZW5kaWFubmVzcyBtYXJrZXIgZm91bmQgaW4gVElGRiBoZWFkZXInKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCB2YWxpZCBUSUZGIGRhdGEhIChubyAweDAwMkEgbWFya2VyKScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzMiBiaXQgbnVtYmVyIHN0YXRpbmcgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgOCBCeXRlIE1QIEhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gTVAgSW5kZXggSUZEIExlYXN0IHBvc3NpYmxlIHZhbHVlIGlzIHRodXMgOCAobWVhbnMgMCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdElGRE9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPCAweDAwMDAwMDA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IHZhbGlkIFRJRkYgZGF0YSEgKEZpcnN0IG9mZnNldCBsZXNzIHRoYW4gOCknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBhaGVhZCB0byBNUCBJbmRleCBJRkRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB3ZSdyZSBhdCB0aGUgZmlyc3QgSUZELCBzbyBmaXJzdElGRE9mZnNldCBwb2ludHMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1QIEluZGV4IElGRCBhbmQgbm90IE1QIEF0dHJpYnV0ZXMgSUZELiAoSWYgd2UgdHJ5IGV4dHJhY3QgZnJvbSBhIHN1YiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZhaWwgc2lsZW50bHkgaGVyZSBkdWUgdG8gdGhpcyBhc3N1bXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgKDIgQnl0ZSkgfCBNUCBJbmRleCBGaWVsZHMgYS5rLmEuIE1QIEVudHJpZXMgKGNvdW50ICogMTIgQnl0ZSkgfCBPZmZzZXQgb2YgTmV4dCBJRkQgKDQgQnl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpclN0YXJ0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0OyAvLyBTdGFydCBvZiBJRkQgKEltYWdlIEZpbGUgRGlyZWN0b3J5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBkYXRhVmlldy5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpOyAvLyBDb3VudCBvZiBNUEVudHJpZXMgKDIgQnl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgaW5mbyBmcm9tIE1QRW50cmllcyAoc3RhcnRpbmcgYWZ0ZXIgQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzU3RhcnQgPSBkaXJTdGFydCArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnVtYmVyT2ZJbWFnZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGVudHJpZXNTdGFydDsgaSA8IGVudHJpZXNTdGFydCArIDEyICogY291bnQ7IGkgKz0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIGVudHJ5IGlzIDEyIEJ5dGVzIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBNUCBJbmRleCBJRkQgdGFncywgaGVyZSB3ZSBvbmx5IHRha2UgdGFnIDB4YjAwMSA9IE51bWJlciBvZiBpbWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KGksICFiaWdFbmQpID09PSAweGIwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmVkIGluIExhc3QgNCBieXRlcyBvZiBpdHMgMTIgQnl0ZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXMgPSBkYXRhVmlldy5nZXRVaW50MzIoaSArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJRkRPZmZzZXRMZW4gPSA0OyAvLyA0IEJ5dGUgb2Zmc2V0IGZpZWxkIHRoYXQgYXBwZWFycyBhZnRlciBNUCBJbmRleCBJRkQgdGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTVBJbWFnZUxpc3RWYWxQdCA9IGRpclN0YXJ0ICsgMiArIGNvdW50ICogMTIgKyBuZXh0SUZET2Zmc2V0TGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gTVBJbWFnZUxpc3RWYWxQdDsgaSA8IE1QSW1hZ2VMaXN0VmFsUHQgKyBudW1iZXJPZkltYWdlcyAqIDE2OyBpICs9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1QVHlwZTogZGF0YVZpZXcuZ2V0VWludDMyKGksICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDQsICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG9mZnNldCBpcyBzcGVjaWZpZWQgcmVsYXRpdmUgdG8gdGhlIGFkZHJlc3Mgb2YgdGhlIE1QIEVuZGlhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCBpbiB0aGUgTVAgSGVhZGVyLCB1bmxlc3MgdGhlIGltYWdlIGlzIGEgRmlyc3QgSW5kaXZpZHVhbCBJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB0aGUgdmFsdWUgb2YgdGhlIG9mZnNldCBzaGFsbCBiZSBOVUxMICgweDAwMDAwMDAwKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldDogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA4LCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kYW50SW1hZ2VzOiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDEyLCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZJSTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2UuZGF0YU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhT2Zmc2V0IGlzIDB4MDAwMDAwMDAgZm9yIEZpcnN0IEluZGl2aWR1YWwgSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zdGFydCA9IHRpZmZPZmZzZXQgKyBpbWFnZS5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5lbmQgPSBpbWFnZS5zdGFydCArIGltYWdlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRyYWN0Tm9uRklJICYmIGltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJCbG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5pc0ZJSSAmJiAhdGhpcy5vcHRpb25zLmV4dHJhY3RGSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIEZJSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGJ1ZmZlckJsb2Iuc2xpY2UoaW1hZ2Uuc3RhcnQsIGltYWdlLmVuZCArIDEsICdpbWFnZS9qcGVnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBpbWFnZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VCbG9iKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZS5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZS5pbWcuc3JjID0gaW1hZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1ncy5wdXNoKGltYWdlQmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW1ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBYTVAgTWV0YWRhdGEgYW5kIHRoZSBnYWluIG1hcCByZWNvdmVyeSBpbWFnZVxuICogZnJvbSBhIHNpbmdsZSBKUEVHIGZpbGUuXG4gKlxuICogQGNhdGVnb3J5IERlY29kaW5nIEZ1bmN0aW9uc1xuICogQGdyb3VwIERlY29kaW5nIEZ1bmN0aW9uc1xuICogQHBhcmFtIGpwZWdGaWxlIGFuIGBVaW50OEFycmF5YCBjb250YWluaW5nIGFuZCBlbmNvZGVkIEpQRUcgZmlsZVxuICogQHJldHVybnMgYW4gc2RyIGBVaW50OEFycmF5YCBjb21wcmVzc2VkIGluIEpQRUcsIGEgZ2Fpbk1hcCBgVWludDhBcnJheWAgY29tcHJlc3NlZCBpbiBKUEVHIGFuZCB0aGUgWE1QIHBhcnNlZCBYTVAgbWV0YWRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgWE1QIE1ldGFkYXRhIGlzIG5vdCBmb3VuZFxuICogQHRocm93cyBFcnJvciBpZiBHYWluIG1hcCBpbWFnZSBpcyBub3QgZm91bmRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWxlTG9hZGVyIH0gZnJvbSAndGhyZWUnXG4gKiBpbXBvcnQgeyBleHRyYWN0R2Fpbm1hcEZyb21KUEVHIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKlxuICogY29uc3QganBlZ0ZpbGUgPSBhd2FpdCBuZXcgRmlsZUxvYWRlcigpXG4gKiAgLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKVxuICogIC5sb2FkQXN5bmMoJ2ltYWdlLmpwZycpXG4gKlxuICogY29uc3QgeyBzZHIsIGdhaW5NYXAsIG1ldGFkYXRhIH0gPSBleHRyYWN0R2Fpbm1hcEZyb21KUEVHKGpwZWdGaWxlKVxuICovXG5jb25zdCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHID0gYXN5bmMgKGpwZWdGaWxlKSA9PiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYWN0WE1QKGpwZWdGaWxlKTtcbiAgICBpZiAoIW1ldGFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yKCdHYWluIG1hcCBYTVAgbWV0YWRhdGEgbm90IGZvdW5kJyk7XG4gICAgY29uc3QgbXBmRXh0cmFjdG9yID0gbmV3IE1QRkV4dHJhY3Rvcih7IGV4dHJhY3RGSUk6IHRydWUsIGV4dHJhY3ROb25GSUk6IHRydWUgfSk7XG4gICAgY29uc3QgaW1hZ2VzID0gYXdhaXQgbXBmRXh0cmFjdG9yLmV4dHJhY3QoanBlZ0ZpbGUpO1xuICAgIGlmIChpbWFnZXMubGVuZ3RoICE9PSAyKVxuICAgICAgICB0aHJvdyBuZXcgR2Fpbk1hcE5vdEZvdW5kRXJyb3IoJ0dhaW4gbWFwIHJlY292ZXJ5IGltYWdlIG5vdCBmb3VuZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNkcjogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgaW1hZ2VzWzBdLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICBnYWluTWFwOiBuZXcgVWludDhBcnJheShhd2FpdCBpbWFnZXNbMV0uYXJyYXlCdWZmZXIoKSksXG4gICAgICAgIG1ldGFkYXRhXG4gICAgfTtcbn07XG5cbi8qKlxuICogcHJpdmF0ZSBmdW5jdGlvbiwgYXN5bmMgZ2V0IGltYWdlIGZyb20gYmxvYlxuICpcbiAqIEBwYXJhbSBibG9iXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBnZXRIVE1MSW1hZ2VGcm9tQmxvYiA9IChibG9iKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7IHJlc29sdmUoaW1nKTsgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IHsgcmVqZWN0KGUpOyB9O1xuICAgICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hhcmVkIGJhc2UgY2xhc3MgZm9yIGxvYWRlcnMgdGhhdCBleHRyYWN0cyBjb21tb24gbG9naWNcbiAqL1xuY2xhc3MgTG9hZGVyQmFzZVNoYXJlZCBleHRlbmRzIExvYWRlciB7XG4gICAgX3JlbmRlcmVyO1xuICAgIF9yZW5kZXJUYXJnZXRPcHRpb25zO1xuICAgIF9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyO1xuICAgIF9jb25maWc7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBtYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChjb25maWcucmVuZGVyZXIpXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IGNvbmZpZy5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuICAgIH1cbiAgICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJlcGFyZVF1YWRSZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBBIFJlbmRlcmVyIHdhcyBub3QgcGFzc2VkIHRvIHRoaXMgTG9hZGVyIGNvbnN0cnVjdG9yIG9yIGluIHNldFJlbmRlcmVyLCB0aGUgcmVzdWx0IG9mIHRoaXMgTG9hZGVyIHdpbGwgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhIFRleHR1cmUgd2l0aCB0b0RhdGFUZXh0dXJlKCkgYmVmb3JlIHlvdSBjYW4gdXNlIGl0IGluIHlvdXIgcmVuZGVyZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLl9jb25maWcuY3JlYXRlTWF0ZXJpYWwoe1xuICAgICAgICAgICAgZ2Fpbk1hcE1heDogWzEsIDEsIDFdLFxuICAgICAgICAgICAgZ2Fpbk1hcE1pbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgZ2FtbWE6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIG9mZnNldEhkcjogWzEsIDEsIDFdLFxuICAgICAgICAgICAgb2Zmc2V0U2RyOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogMSxcbiAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiAwLFxuICAgICAgICAgICAgbWF4RGlzcGxheUJvb3N0OiAxLFxuICAgICAgICAgICAgZ2Fpbk1hcDogbmV3IFRleHR1cmUoKSxcbiAgICAgICAgICAgIHNkcjogbmV3IFRleHR1cmUoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5jcmVhdGVRdWFkUmVuZGVyZXIoe1xuICAgICAgICAgICAgd2lkdGg6IDE2LFxuICAgICAgICAgICAgaGVpZ2h0OiAxNixcbiAgICAgICAgICAgIHR5cGU6IEhhbGZGbG9hdFR5cGUsXG4gICAgICAgICAgICBjb2xvclNwYWNlOiBMaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgICAgcmVuZGVyZXI6IHRoaXMuX3JlbmRlcmVyLFxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0T3B0aW9uczogdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0ltYWdlcyhzZHJCdWZmZXIsIGdhaW5NYXBCdWZmZXIsIGltYWdlT3JpZW50YXRpb24pIHtcbiAgICAgICAgY29uc3QgZ2Fpbk1hcEJsb2IgPSBnYWluTWFwQnVmZmVyID8gbmV3IEJsb2IoW2dhaW5NYXBCdWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2RyQmxvYiA9IG5ldyBCbG9iKFtzZHJCdWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgICAgbGV0IHNkckltYWdlO1xuICAgICAgICBsZXQgZ2Fpbk1hcEltYWdlO1xuICAgICAgICBsZXQgbmVlZHNGbGlwID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEJsb2IgPyBnZXRIVE1MSW1hZ2VGcm9tQmxvYihnYWluTWFwQmxvYikgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBnZXRIVE1MSW1hZ2VGcm9tQmxvYihzZHJCbG9iKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBnYWluTWFwSW1hZ2UgPSByZXNbMF07XG4gICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgICAgIG5lZWRzRmxpcCA9IGltYWdlT3JpZW50YXRpb24gPT09ICdmbGlwWSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEJsb2IgPyBjcmVhdGVJbWFnZUJpdG1hcChnYWluTWFwQmxvYiwgeyBpbWFnZU9yaWVudGF0aW9uOiBpbWFnZU9yaWVudGF0aW9uIHx8ICdmbGlwWScgfSkgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChzZHJCbG9iLCB7IGltYWdlT3JpZW50YXRpb246IGltYWdlT3JpZW50YXRpb24gfHwgJ2ZsaXBZJyB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBnYWluTWFwSW1hZ2UgPSByZXNbMF07XG4gICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZHJJbWFnZSwgZ2Fpbk1hcEltYWdlLCBuZWVkc0ZsaXAgfTtcbiAgICB9XG4gICAgY3JlYXRlVGV4dHVyZXMoc2RySW1hZ2UsIGdhaW5NYXBJbWFnZSwgbmVlZHNGbGlwKSB7XG4gICAgICAgIGNvbnN0IGdhaW5NYXAgPSBuZXcgVGV4dHVyZShnYWluTWFwSW1hZ2UgfHwgbmV3IEltYWdlRGF0YSgyLCAyKSwgVVZNYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgMSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBnYWluTWFwLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICBnYWluTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2RyID0gbmV3IFRleHR1cmUoc2RySW1hZ2UsIFVWTWFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIFJHQkFGb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIDEsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2RyLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICBzZHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4geyBnYWluTWFwLCBzZHIgfTtcbiAgICB9XG4gICAgdXBkYXRlUXVhZFJlbmRlcmVyKHF1YWRSZW5kZXJlciwgc2RySW1hZ2UsIGdhaW5NYXAsIHNkciwgbWV0YWRhdGEpIHtcbiAgICAgICAgcXVhZFJlbmRlcmVyLndpZHRoID0gc2RySW1hZ2Uud2lkdGg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5oZWlnaHQgPSBzZHJJbWFnZS5oZWlnaHQ7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwID0gZ2Fpbk1hcDtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLnNkciA9IHNkcjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXBNaW4gPSBtZXRhZGF0YS5nYWluTWFwTWluO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2Fpbk1hcE1heCA9IG1ldGFkYXRhLmdhaW5NYXBNYXg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRIZHIgPSBtZXRhZGF0YS5vZmZzZXRIZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRTZHIgPSBtZXRhZGF0YS5vZmZzZXRTZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYW1tYSA9IG1ldGFkYXRhLmdhbW1hO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuaGRyQ2FwYWNpdHlNaW4gPSBtZXRhZGF0YS5oZHJDYXBhY2l0eU1pbjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmhkckNhcGFjaXR5TWF4ID0gbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5tYXhEaXNwbGF5Qm9vc3QgPSBNYXRoLnBvdygyLCBtZXRhZGF0YS5oZHJDYXBhY2l0eU1heCk7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgeyBHYWluTWFwTm90Rm91bmRFcnJvciBhcyBHLCBMb2FkZXJCYXNlU2hhcmVkIGFzIEwsIE1QRkV4dHJhY3RvciBhcyBNLCBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IgYXMgWCwgZXh0cmFjdFhNUCBhcyBhLCBjcmVhdGVEZWNvZGVGdW5jdGlvbiBhcyBjLCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHIGFzIGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ QuadRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */\n\n\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    _renderer;\n    _rendererIsDisposable = false;\n    _material;\n    _scene;\n    _camera;\n    _quad;\n    _renderTarget;\n    _width;\n    _height;\n    _type;\n    _colorSpace;\n    _supportsReadPixels = true;\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: options.renderTargetOptions?.anisotropy !== undefined ? options.renderTargetOptions?.anisotropy : 1,\n            generateMipmaps: options.renderTargetOptions?.generateMipmaps !== undefined ? options.renderTargetOptions?.generateMipmaps : false,\n            magFilter: options.renderTargetOptions?.magFilter !== undefined ? options.renderTargetOptions?.magFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            minFilter: options.renderTargetOptions?.minFilter !== undefined ? options.renderTargetOptions?.minFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            samples: options.renderTargetOptions?.samples !== undefined ? options.renderTargetOptions?.samples : undefined,\n            wrapS: options.renderTargetOptions?.wrapS !== undefined ? options.renderTargetOptions?.wrapS : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n            wrapT: options.renderTargetOptions?.wrapT !== undefined ? options.renderTargetOptions?.wrapT : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this._camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? three__WEBPACK_IMPORTED_MODULE_0__.FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three__WEBPACK_IMPORTED_MODULE_0__.FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = options.renderTargetOptions?.mapping !== undefined ? options.renderTargetOptions?.mapping : three__WEBPACK_IMPORTED_MODULE_0__.UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Renders the input texture using the specified material\n     */\n    render = () => {\n        this._renderer.setRenderTarget(this._renderTarget);\n        try {\n            this._renderer.render(this._scene, this._camera);\n        }\n        catch (e) {\n            this._renderer.setRenderTarget(null);\n            throw e;\n        }\n        this._renderer.setRenderTarget(null);\n    };\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, this._type, \n        // user values\n        options?.mapping || three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, options?.wrapS || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, options?.wrapT || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, options?.magFilter || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, options?.minFilter || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, options?.anisotropy || 1, \n        // fixed value\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = options?.generateMipmaps !== undefined ? options?.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItQmoxeGxfRUsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNlU7O0FBRTdVO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQWdCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhLGdEQUFhO0FBQzFCO0FBQ0E7QUFDQSxhQUFhLGtEQUFlO0FBQzVCO0FBQ0E7QUFDQSxhQUFhLDJDQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLDRDQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLDBDQUFPO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLDRDQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQWlCO0FBQ3hDO0FBQ0EscUJBQXFCLHVDQUFJLEtBQUssZ0RBQWEsUUFBUSxvREFBaUIsR0FBRyxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCwrQ0FBWTtBQUNuSSx1SEFBdUgsK0NBQVk7QUFDbkk7QUFDQSwyR0FBMkcsc0RBQW1CO0FBQzlILDJHQUEyRyxzREFBbUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdDQUFLO0FBQy9CLDJCQUEyQixxREFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFhO0FBQ2xDLGdHQUFnRyw0Q0FBUztBQUN6RztBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsWUFBWSw4QkFBOEIsNENBQVMsQ0FBQztBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1Q0FBSSxLQUFLLGdEQUFhO0FBQy9DO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQWlCO0FBQ2xELHlJQUF5SSw0Q0FBUztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQVc7QUFDM0M7QUFDQSxpREFBaUQsNkNBQVU7QUFDM0Q7QUFDQSw0QkFBNEIsNENBQVMsb0JBQW9CLHNEQUFtQixvQkFBb0Isc0RBQW1CLHdCQUF3QiwrQ0FBWSx3QkFBd0IsK0NBQVk7QUFDM0w7QUFDQSxRQUFRLHVEQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtDQUFrQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpREFBYztBQUNuRDtBQUNBLHVDQUF1QywwQ0FBTztBQUM5QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQU87QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2Qjs7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcnFwcmVtaS8uL25vZGVfbW9kdWxlcy9AbW9ub2dyaWQvZ2Fpbm1hcC1qcy9kaXN0L1F1YWRSZW5kZXJlci1CajF4bF9FSy5qcz81ZTdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vbm9ncmlkL2dhaW5tYXAtanMgdjMuNC4wXG4gKiBXaXRoIOKdpO+4jywgYnkgTU9OT0dSSUQgPGdhaW5tYXBAbW9ub2dyaWQuY29tPlxuICovXG5cbmltcG9ydCB7IENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgU2NlbmUsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBNZXNoLCBQbGFuZUdlb21ldHJ5LCBXZWJHTFJlbmRlclRhcmdldCwgUkdCQUZvcm1hdCwgVVZNYXBwaW5nLCBXZWJHTFJlbmRlcmVyLCBEYXRhVGV4dHVyZSwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIFNoYWRlck1hdGVyaWFsLCBUZXh0dXJlLCBNZXNoQmFzaWNNYXRlcmlhbCwgSW50VHlwZSwgU2hvcnRUeXBlLCBCeXRlVHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZEJ5dGVUeXBlIH0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBnZXRCdWZmZXJGb3JUeXBlID0gKHR5cGUsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBsZXQgb3V0O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFVuc2lnbmVkQnl0ZVR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFVuc2lnbmVkSW50VHlwZTpcbiAgICAgICAgICAgIG91dCA9IG5ldyBVaW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQnl0ZVR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTaG9ydFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50MTZBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50VHlwZTpcbiAgICAgICAgICAgIG91dCA9IG5ldyBJbnQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xubGV0IF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuLyoqXG4gKiBUZXN0IGlmIHRoaXMgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBjYW4gY29ycmVjdGx5IHJlYWQgcGl4ZWxzIGZyb20gdGhlIHNwZWNpZmllZFxuICogUmVuZGVyIHRhcmdldCB0eXBlLlxuICpcbiAqIFJ1bnMgb25seSBvbmNlXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSByZW5kZXJlclxuICogQHBhcmFtIGNhbWVyYVxuICogQHBhcmFtIHJlbmRlclRhcmdldE9wdGlvbnNcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGNhblJlYWRQaXhlbHMgPSAodHlwZSwgcmVuZGVyZXIsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0T3B0aW9ucykgPT4ge1xuICAgIGlmIChfY2FuUmVhZFBpeGVsc1Jlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG4gICAgY29uc3QgdGVzdFJUID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHJlbmRlclRhcmdldE9wdGlvbnMpO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0ZXN0UlQpO1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgpLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZmYgfSkpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihtZXNoLCBjYW1lcmEpO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICBjb25zdCBvdXQgPSBnZXRCdWZmZXJGb3JUeXBlKHR5cGUsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCk7XG4gICAgcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0ZXN0UlQsIDAsIDAsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCwgb3V0KTtcbiAgICB0ZXN0UlQuZGlzcG9zZSgpO1xuICAgIG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIG1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgIF9jYW5SZWFkUGl4ZWxzUmVzdWx0ID0gb3V0WzBdICE9PSAwO1xuICAgIHJldHVybiBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbn07XG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgdXNlZCBmb3IgcmVuZGVyaW5nIGEgdGV4dHVyZSB3aXRoIGEgbWF0ZXJpYWxcbiAqXG4gKiBAY2F0ZWdvcnkgQ29yZVxuICogQGdyb3VwIENvcmVcbiAqL1xuY2xhc3MgUXVhZFJlbmRlcmVyIHtcbiAgICBfcmVuZGVyZXI7XG4gICAgX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gZmFsc2U7XG4gICAgX21hdGVyaWFsO1xuICAgIF9zY2VuZTtcbiAgICBfY2FtZXJhO1xuICAgIF9xdWFkO1xuICAgIF9yZW5kZXJUYXJnZXQ7XG4gICAgX3dpZHRoO1xuICAgIF9oZWlnaHQ7XG4gICAgX3R5cGU7XG4gICAgX2NvbG9yU3BhY2U7XG4gICAgX3N1cHBvcnRzUmVhZFBpeGVscyA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBRdWFkUmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFBhcmFtZXRlcnMgZm9yIHRoaXMgUXVhZFJlbmRlcmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLl90eXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgICB0aGlzLl9jb2xvclNwYWNlID0gb3B0aW9ucy5jb2xvclNwYWNlO1xuICAgICAgICBjb25zdCBydE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBmaXhlZCBvcHRpb25zXG4gICAgICAgICAgICBmb3JtYXQ6IFJHQkFGb3JtYXQsXG4gICAgICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBzdGVuY2lsQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHVzZXIgb3B0aW9uc1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fdHlwZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aGlzLl9jb2xvclNwYWNlLCAvLyBzZXQgaW4gY2xhc3MgcHJvcGVydHlcbiAgICAgICAgICAgIGFuaXNvdHJvcHk6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5hbmlzb3Ryb3B5IDogMSxcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwbWFwczogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2UsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIG1pbkZpbHRlcjogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ubWluRmlsdGVyIDogTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgc2FtcGxlczogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5zYW1wbGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LnNhbXBsZXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3cmFwUzogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gICAgICAgICAgICB3cmFwVDogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwVCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBRdWFkUmVuZGVyZXIuaW5zdGFudGlhdGVSZW5kZXJlcigpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjZW5lID0gbmV3IFNjZW5lKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAxMCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5sZWZ0ID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnJpZ2h0ID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEudG9wID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEuYm90dG9tID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgaWYgKCFjYW5SZWFkUGl4ZWxzKHRoaXMuX3R5cGUsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9jYW1lcmEsIHJ0T3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlVHlwZSA9IHRoaXMuX3JlbmRlcmVyLmV4dGVuc2lvbnMuaGFzKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykgPyBGbG9hdFR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIHBpeGVscyBmcm9tICR7dGhpcy5fdHlwZX0gUmVuZGVyVGFyZ2V0cywgc3dpdGNoaW5nIHRvICR7RmxvYXRUeXBlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c1JlYWRQaXhlbHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb3Mgbm90IHN1cHBvcnQgdG9BcnJheSBvciB0b0RhdGFUZXh0dXJlLCBjYWxscyB0byB0aG9zZSBtZXRob2RzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIHRocm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3F1YWQgPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgpLCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuX3F1YWQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9xdWFkKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBydE9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQudGV4dHVyZS5tYXBwaW5nID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5tYXBwaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1hcHBpbmcgOiBVVk1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIHRlbXBvcmFyeSByZW5kZXJlclxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zdGFudGlhdGVSZW5kZXJlcigpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpO1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKDEyOCwgMTI4KTtcbiAgICAgICAgLy8gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlXG4gICAgICAgIC8vIHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmdcbiAgICAgICAgLy8gcmVuZGVyZXIuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMgPSBmYWxzZVxuICAgICAgICAvLyB0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBpbnB1dCB0ZXh0dXJlIHVzaW5nIHRoZSBzcGVjaWZpZWQgbWF0ZXJpYWxcbiAgICAgKi9cbiAgICByZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLl9yZW5kZXJUYXJnZXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX3NjZW5lLCB0aGlzLl9jYW1lcmEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9idGFpbnMgYSBCdWZmZXIgY29udGFpbmluZyB0aGUgcmVuZGVyZWQgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGJyb3dzZXIgY2Fubm90IHJlYWQgcGl4ZWxzIGZyb20gdGhpcyBSZW5kZXJUYXJnZXQgdHlwZS5cbiAgICAgKiBAcmV0dXJucyBhIFR5cGVkQXJyYXkgY29udGFpbmluZyBSR0JBIHZhbHVlcyBmcm9tIHRoaXMgcmVuZGVyZXJcbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCByZWFkIHBpeGVscyBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gZ2V0QnVmZmVyRm9yVHlwZSh0aGlzLl90eXBlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0aGlzLl9yZW5kZXJUYXJnZXQsIDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVhZFBpeGVsIG9wZXJhdGlvbiBpbiB0aGUgcmVuZGVyVGFyZ2V0XG4gICAgICogYW5kIHJldHVybnMgYSBEYXRhVGV4dHVyZSBjb250YWluaW5nIHRoZSByZWFkIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHRvRGF0YVRleHR1cmUob3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG5ldyBEYXRhVGV4dHVyZShcbiAgICAgICAgLy8gZml4ZWQgdmFsdWVzXG4gICAgICAgIHRoaXMudG9BcnJheSgpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgUkdCQUZvcm1hdCwgdGhpcy5fdHlwZSwgXG4gICAgICAgIC8vIHVzZXIgdmFsdWVzXG4gICAgICAgIG9wdGlvbnM/Lm1hcHBpbmcgfHwgVVZNYXBwaW5nLCBvcHRpb25zPy53cmFwUyB8fCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBvcHRpb25zPy53cmFwVCB8fCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBvcHRpb25zPy5tYWdGaWx0ZXIgfHwgTGluZWFyRmlsdGVyLCBvcHRpb25zPy5taW5GaWx0ZXIgfHwgTGluZWFyRmlsdGVyLCBvcHRpb25zPy5hbmlzb3Ryb3B5IHx8IDEsIFxuICAgICAgICAvLyBmaXhlZCB2YWx1ZVxuICAgICAgICBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIC8vIHNldCB0aGlzIGFmdGVyd2FyZHMsIHdlIGNhbid0IHNldCBpdCBpbiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm5WYWx1ZS5nZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zPy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnM/LmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIGEgZGlzcG9zYWJsZSByZW5kZXJlciwgaXQgd2lsbCBkaXNwb3NlIGl0LlxuICAgICAqL1xuICAgIGRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgZGlzcG9zZSBvZiAqKmFsbCoqIGFzc2V0cyB1c2VkIGJ5IHRoaXMgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNwb3NlUmVuZGVyVGFyZ2V0IHdpbGwgZGlzcG9zZSBvZiB0aGUgcmVuZGVyVGFyZ2V0IHdoaWNoIHdpbGwgbm90IGJlIHVzYWJsZSBsYXRlclxuICAgICAqIHNldCB0aGlzIHRvIHRydWUgaWYgeW91IHBhc3NlZCB0aGUgYHJlbmRlclRhcmdldC50ZXh0dXJlYCB0byBhIGBQTVJFTUdlbmVyYXRvcmBcbiAgICAgKiBvciBhcmUgb3RoZXJ3aXNlIGRvbmUgd2l0aCBpdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsb2FkZXIgPSBuZXcgSERSSlBHTG9hZGVyKHJlbmRlcmVyKVxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KSApXG4gICAgICogLy8gRE8gTk9UIGRpc3Bvc2UgdGhlIHJlbmRlclRhcmdldCBoZXJlLFxuICAgICAqIC8vIGl0IGlzIHVzZWQgZGlyZWN0bHkgaW4gdGhlIG1hdGVyaWFsXG4gICAgICogcmVzdWx0LmRpc3Bvc2UoKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICogY29uc3QgcG1yZW1HZW5lcmF0b3IgPSBuZXcgUE1SRU1HZW5lcmF0b3IoIHJlbmRlcmVyICk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAgICAgKiBjb25zdCBlbnZNYXAgPSBwbXJlbUdlbmVyYXRvci5mcm9tRXF1aXJlY3Rhbmd1bGFyKHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSlcbiAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7IGVudk1hcCB9KSApXG4gICAgICogLy8gcmVuZGVyVGFyZ2V0IGNhbiBiZSBkaXNwb3NlZCBoZXJlXG4gICAgICogLy8gYmVjYXVzZSBpdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSBhIFBNUkVNIHRleHR1cmVcbiAgICAgKiByZXN1bHQuZGlzcG9zZSh0cnVlKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRpc3Bvc2UoZGlzcG9zZVJlbmRlclRhcmdldCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgIGlmIChkaXNwb3NlUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcG9zZSBzaGFkZXIgbWF0ZXJpYWwgdGV4dHVyZSB1bmlmb3Jtc1xuICAgICAgICBpZiAodGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIFNoYWRlck1hdGVyaWFsKSB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubWF0ZXJpYWwudW5pZm9ybXMpLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHYudmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICB2LnZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpc3Bvc2Ugb3RoZXIgbWF0ZXJpYWwgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubWF0ZXJpYWwpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSlcbiAgICAgICAgICAgICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcXVhZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fd2lkdGg7IH1cbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLl9oZWlnaHQ7IH1cbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlbmRlcmVyIHVzZWRcbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJlcjsgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgV2ViR0xSZW5kZXJUYXJnZXRgIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHJlbmRlclRhcmdldCgpIHsgcmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldDsgfVxuICAgIHNldCByZW5kZXJUYXJnZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWUud2lkdGg7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlLmhlaWdodDtcbiAgICAgICAgLy8gdGhpcy5fdHlwZSA9IHZhbHVlLnRleHR1cmUudHlwZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYE1hdGVyaWFsYCB1c2VkLlxuICAgICAqL1xuICAgIGdldCBtYXRlcmlhbCgpIHsgcmV0dXJuIHRoaXMuX21hdGVyaWFsOyB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3R5cGU7IH1cbiAgICBnZXQgY29sb3JTcGFjZSgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yU3BhY2U7IH1cbn1cblxuZXhwb3J0IHsgUXVhZFJlbmRlcmVyIGFzIFEgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GainMapDecoderMaterial: () => (/* binding */ GainMapDecoderMaterial),\n/* harmony export */   GainMapLoader: () => (/* binding */ GainMapLoader),\n/* harmony export */   GainMapNotFoundError: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   HDRJPGLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   JPEGRLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   LoaderBaseShared: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   MPFExtractor: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   QuadRenderer: () => (/* reexport safe */ _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__.Q),\n/* harmony export */   XMPMetadataNotFoundError: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   createDecodeFunction: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   extractGainmapFromJPEG: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   extractXMP: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.a)\n/* harmony export */ });\n/* harmony import */ var _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QuadRenderer-Bj1xl_EK.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js\");\n/* harmony import */ var _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Loader-DLI-_JDP.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */\n\n\n\n\n\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial {\n    _maxDisplayBoost;\n    _hdrCapacityMin;\n    _hdrCapacityMax;\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_1__.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\nconst decodeImpl = (0,_Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.c)({\n    renderer: three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer,\n    createMaterial: (params) => new GainMapDecoderMaterial(params),\n    createQuadRenderer: (params) => new _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__.Q(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    // Ensure renderer is defined for the base function\n    if (!params.renderer) {\n        throw new Error('Renderer is required for decode function');\n    }\n    const quadRenderer = decodeImpl({\n        ...params,\n        renderer: params.renderer\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */\nclass LoaderBaseWebGL extends _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.L {\n    constructor(renderer, manager) {\n        super({\n            renderer,\n            createMaterial: (params) => new GainMapDecoderMaterial(params),\n            createQuadRenderer: (params) => new _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__.Q(params)\n        }, manager);\n    }\n    /**\n     * @private\n     * @param quadRenderer\n     * @param metadata\n     * @param sdrBuffer\n     * @param gainMapBuffer\n     */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        const { sdrImage, gainMapImage, needsFlip } = await this.processImages(sdrBuffer, gainMapBuffer, 'flipY');\n        const { gainMap, sdr } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n        this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url Path to a JPEG file containing embedded gain map metadata\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await (0,_Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.e)(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.X || e instanceof _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.G) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUUrRDtBQUNnSDtBQUNyRztBQUNhOztBQUV2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0hBQW9IO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQywyQkFBMkIsZ0JBQWdCO0FBQzNDLHlCQUF5QixXQUFXLDBDQUFPLGtEQUFrRDtBQUM3Riw2QkFBNkIsV0FBVywwQ0FBTyx5QkFBeUI7QUFDeEUsNkJBQTZCLFdBQVcsMENBQU8seUJBQXlCO0FBQ3hFLDhCQUE4QixXQUFXLDBDQUFPLDBCQUEwQjtBQUMxRSw4QkFBOEIsV0FBVywwQ0FBTywwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQiw2Q0FBVTtBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QjtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVrTyIsInNvdXJjZXMiOlsid2VicGFjazovL2FycXByZW1pLy4vbm9kZV9tb2R1bGVzL0Btb25vZ3JpZC9nYWlubWFwLWpzL2Rpc3QvZGVjb2RlLmpzP2EwYjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9ub2dyaWQvZ2Fpbm1hcC1qcyB2My40LjBcbiAqIFdpdGgg4p2k77iPLCBieSBNT05PR1JJRCA8Z2Fpbm1hcEBtb25vZ3JpZC5jb20+XG4gKi9cblxuaW1wb3J0IHsgUSBhcyBRdWFkUmVuZGVyZXIgfSBmcm9tICcuL1F1YWRSZW5kZXJlci1CajF4bF9FSy5qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZURlY29kZUZ1bmN0aW9uLCBMIGFzIExvYWRlckJhc2VTaGFyZWQsIGUgYXMgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRywgWCBhcyBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IsIEcgYXMgR2Fpbk1hcE5vdEZvdW5kRXJyb3IgfSBmcm9tICcuL0xvYWRlci1ETEktX0pEUC5qcyc7XG5leHBvcnQgeyBNIGFzIE1QRkV4dHJhY3RvciwgYSBhcyBleHRyYWN0WE1QIH0gZnJvbSAnLi9Mb2FkZXItRExJLV9KRFAuanMnO1xuaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIE5vQmxlbmRpbmcsIFZlY3RvcjMsIFdlYkdMUmVuZGVyZXIsIEZpbGVMb2FkZXIgfSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IHZlcnRleFNoYWRlciA9IC8qIGdsc2wgKi8gYFxudmFyeWluZyB2ZWMyIHZVdjtcblxudm9pZCBtYWluKCkge1xuICB2VXYgPSB1djtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbn1cbmA7XG5jb25zdCBmcmFnbWVudFNoYWRlciA9IC8qIGdsc2wgKi8gYFxuLy8gbWluIGhhbGYgZmxvYXQgdmFsdWVcbiNkZWZpbmUgSEFMRl9GTE9BVF9NSU4gdmVjMyggLTY1NTA0LCAtNjU1MDQsIC02NTUwNCApXG4vLyBtYXggaGFsZiBmbG9hdCB2YWx1ZVxuI2RlZmluZSBIQUxGX0ZMT0FUX01BWCB2ZWMzKCA2NTUwNCwgNjU1MDQsIDY1NTA0IClcblxudW5pZm9ybSBzYW1wbGVyMkQgc2RyO1xudW5pZm9ybSBzYW1wbGVyMkQgZ2Fpbk1hcDtcbnVuaWZvcm0gdmVjMyBnYW1tYTtcbnVuaWZvcm0gdmVjMyBvZmZzZXRIZHI7XG51bmlmb3JtIHZlYzMgb2Zmc2V0U2RyO1xudW5pZm9ybSB2ZWMzIGdhaW5NYXBNaW47XG51bmlmb3JtIHZlYzMgZ2Fpbk1hcE1heDtcbnVuaWZvcm0gZmxvYXQgd2VpZ2h0RmFjdG9yO1xuXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG52b2lkIG1haW4oKSB7XG4gIHZlYzMgcmdiID0gdGV4dHVyZTJEKCBzZHIsIHZVdiApLnJnYjtcbiAgdmVjMyByZWNvdmVyeSA9IHRleHR1cmUyRCggZ2Fpbk1hcCwgdlV2ICkucmdiO1xuICB2ZWMzIGxvZ1JlY292ZXJ5ID0gcG93KCByZWNvdmVyeSwgZ2FtbWEgKTtcbiAgdmVjMyBsb2dCb29zdCA9IGdhaW5NYXBNaW4gKiAoIDEuMCAtIGxvZ1JlY292ZXJ5ICkgKyBnYWluTWFwTWF4ICogbG9nUmVjb3Zlcnk7XG4gIHZlYzMgaGRyQ29sb3IgPSAocmdiICsgb2Zmc2V0U2RyKSAqIGV4cDIoIGxvZ0Jvb3N0ICogd2VpZ2h0RmFjdG9yICkgLSBvZmZzZXRIZHI7XG4gIHZlYzMgY2xhbXBlZEhkckNvbG9yID0gbWF4KCBIQUxGX0ZMT0FUX01JTiwgbWluKCBIQUxGX0ZMT0FUX01BWCwgaGRyQ29sb3IgKSk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNsYW1wZWRIZHJDb2xvciAsIDEuMCApO1xufVxuYDtcbi8qKlxuICogQSBNYXRlcmlhbCB3aGljaCBpcyBhYmxlIHRvIGRlY29kZSB0aGUgR2Fpbm1hcCBpbnRvIGEgZnVsbCBIRFIgUmVwcmVzZW50YXRpb25cbiAqXG4gKiBAY2F0ZWdvcnkgTWF0ZXJpYWxzXG4gKiBAZ3JvdXAgTWF0ZXJpYWxzXG4gKi9cbmNsYXNzIEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XG4gICAgX21heERpc3BsYXlCb29zdDtcbiAgICBfaGRyQ2FwYWNpdHlNaW47XG4gICAgX2hkckNhcGFjaXR5TWF4O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgZ2FtbWEsIG9mZnNldEhkciwgb2Zmc2V0U2RyLCBnYWluTWFwTWluLCBnYWluTWFwTWF4LCBtYXhEaXNwbGF5Qm9vc3QsIGhkckNhcGFjaXR5TWluLCBoZHJDYXBhY2l0eU1heCwgc2RyLCBnYWluTWFwIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ0dhaW5NYXBEZWNvZGVyTWF0ZXJpYWwnLFxuICAgICAgICAgICAgdmVydGV4U2hhZGVyLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgIHNkcjogeyB2YWx1ZTogc2RyIH0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcDogeyB2YWx1ZTogZ2Fpbk1hcCB9LFxuICAgICAgICAgICAgICAgIGdhbW1hOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygxLjAgLyBnYW1tYVswXSwgMS4wIC8gZ2FtbWFbMV0sIDEuMCAvIGdhbW1hWzJdKSB9LFxuICAgICAgICAgICAgICAgIG9mZnNldEhkcjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkob2Zmc2V0SGRyKSB9LFxuICAgICAgICAgICAgICAgIG9mZnNldFNkcjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkob2Zmc2V0U2RyKSB9LFxuICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGdhaW5NYXBNaW4pIH0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1heDogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoZ2Fpbk1hcE1heCkgfSxcbiAgICAgICAgICAgICAgICB3ZWlnaHRGYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IChNYXRoLmxvZzIobWF4RGlzcGxheUJvb3N0KSAtIGhkckNhcGFjaXR5TWluKSAvIChoZHJDYXBhY2l0eU1heCAtIGhkckNhcGFjaXR5TWluKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibGVuZGluZzogTm9CbGVuZGluZyxcbiAgICAgICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWF4RGlzcGxheUJvb3N0ID0gbWF4RGlzcGxheUJvb3N0O1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1pbiA9IGhkckNhcGFjaXR5TWluO1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1heCA9IGhkckNhcGFjaXR5TWF4O1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlmb3Jtc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgc2RyKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5zZHIudmFsdWU7IH1cbiAgICBzZXQgc2RyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuc2RyLnZhbHVlID0gdmFsdWU7IH1cbiAgICBnZXQgZ2Fpbk1hcCgpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcC52YWx1ZTsgfVxuICAgIHNldCBnYWluTWFwKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuZ2Fpbk1hcC52YWx1ZSA9IHZhbHVlOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLm9mZnNldEhkcn1cbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0SGRyKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXRIZHIudmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IG9mZnNldEhkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLm9mZnNldEhkci52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLm9mZnNldFNkcn1cbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0U2RyKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXRTZHIudmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IG9mZnNldFNkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLm9mZnNldFNkci52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhaW5NYXBNaW59XG4gICAgICovXG4gICAgZ2V0IGdhaW5NYXBNaW4oKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNaW4udmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IGdhaW5NYXBNaW4odmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwTWluLnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2Fpbk1hcE1heH1cbiAgICAgKi9cbiAgICBnZXQgZ2Fpbk1hcE1heCgpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1heC52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgZ2Fpbk1hcE1heCh2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNYXgudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYW1tYX1cbiAgICAgKi9cbiAgICBnZXQgZ2FtbWEoKSB7XG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaWZvcm1zLmdhbW1hLnZhbHVlO1xuICAgICAgICByZXR1cm4gWzEgLyBnLngsIDEgLyBnLnksIDEgLyBnLnpdO1xuICAgIH1cbiAgICBzZXQgZ2FtbWEodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pZm9ybXMuZ2FtbWEudmFsdWU7XG4gICAgICAgIGcueCA9IDEuMCAvIHZhbHVlWzBdO1xuICAgICAgICBnLnkgPSAxLjAgLyB2YWx1ZVsxXTtcbiAgICAgICAgZy56ID0gMS4wIC8gdmFsdWVbMl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5oZHJDYXBhY2l0eU1pbn1cbiAgICAgKiBAcmVtYXJrcyBMb2dhcml0aG1pYyBzcGFjZVxuICAgICAqL1xuICAgIGdldCBoZHJDYXBhY2l0eU1pbigpIHsgcmV0dXJuIHRoaXMuX2hkckNhcGFjaXR5TWluOyB9XG4gICAgc2V0IGhkckNhcGFjaXR5TWluKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWluID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5oZHJDYXBhY2l0eU1pbn1cbiAgICAgKiBAcmVtYXJrcyBMb2dhcml0aG1pYyBzcGFjZVxuICAgICAqL1xuICAgIGdldCBoZHJDYXBhY2l0eU1heCgpIHsgcmV0dXJuIHRoaXMuX2hkckNhcGFjaXR5TWF4OyB9XG4gICAgc2V0IGhkckNhcGFjaXR5TWF4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWF4ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5tYXBEZWNvZGluZ1BhcmFtZXRlcnMubWF4RGlzcGxheUJvb3N0fVxuICAgICAqIEByZW1hcmtzIE5vbiBMb2dhcml0aG1pYyBzcGFjZVxuICAgICAqL1xuICAgIGdldCBtYXhEaXNwbGF5Qm9vc3QoKSB7IHJldHVybiB0aGlzLl9tYXhEaXNwbGF5Qm9vc3Q7IH1cbiAgICBzZXQgbWF4RGlzcGxheUJvb3N0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21heERpc3BsYXlCb29zdCA9IE1hdGgubWF4KDEsIE1hdGgubWluKDY1NTA0LCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVXZWlnaHQoKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IChNYXRoLmxvZzIodGhpcy5fbWF4RGlzcGxheUJvb3N0KSAtIHRoaXMuX2hkckNhcGFjaXR5TWluKSAvICh0aGlzLl9oZHJDYXBhY2l0eU1heCAtIHRoaXMuX2hkckNhcGFjaXR5TWluKTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy53ZWlnaHRGYWN0b3IudmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWwpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlY29kZUltcGwgPSBjcmVhdGVEZWNvZGVGdW5jdGlvbih7XG4gICAgcmVuZGVyZXI6IFdlYkdMUmVuZGVyZXIsXG4gICAgY3JlYXRlTWF0ZXJpYWw6IChwYXJhbXMpID0+IG5ldyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsKHBhcmFtcyksXG4gICAgY3JlYXRlUXVhZFJlbmRlcmVyOiAocGFyYW1zKSA9PiBuZXcgUXVhZFJlbmRlcmVyKHBhcmFtcylcbn0pO1xuLyoqXG4gKiBEZWNvZGVzIGEgZ2FpbiBtYXAgdXNpbmcgYSBXZWJHTCBSZW5kZXJUYXJnZXRcbiAqXG4gKiBAY2F0ZWdvcnkgRGVjb2RpbmcgRnVuY3Rpb25zXG4gKiBAZ3JvdXAgRGVjb2RpbmcgRnVuY3Rpb25zXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKiBpbXBvcnQge1xuICogICBNZXNoLFxuICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gKiAgIFBsYW5lR2VvbWV0cnksXG4gKiAgIFNjZW5lLFxuICogICBUZXh0dXJlTG9hZGVyLFxuICogICBXZWJHTFJlbmRlcmVyXG4gKiB9IGZyb20gJ3RocmVlJ1xuICpcbiAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICpcbiAqIGNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpXG4gKlxuICogLy8gbG9hZCBTRFIgUmVwcmVzZW50YXRpb25cbiAqIGNvbnN0IHNkciA9IGF3YWl0IHRleHR1cmVMb2FkZXIubG9hZEFzeW5jKCdzZHIuanBnJylcbiAqIC8vIGxvYWQgR2FpbiBtYXAgcmVjb3ZlcnkgaW1hZ2VcbiAqIGNvbnN0IGdhaW5NYXAgPSBhd2FpdCB0ZXh0dXJlTG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGcnKVxuICogLy8gbG9hZCBtZXRhZGF0YVxuICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCAoYXdhaXQgZmV0Y2goJ21ldGFkYXRhLmpzb24nKSkuanNvbigpXG4gKlxuICogY29uc3QgcmVzdWx0ID0gZGVjb2RlKHtcbiAqICAgc2RyLFxuICogICBnYWluTWFwLFxuICogICAvLyB0aGlzIGFsbG93cyB0byB1c2UgYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgZGlyZWN0bHlcbiAqICAgcmVuZGVyZXIsXG4gKiAgIC8vIHRoaXMgd2lsbCByZXN0b3JlIHRoZSBmdWxsIEhEUiByYW5nZVxuICogICBtYXhEaXNwbGF5Qm9vc3Q6IE1hdGgucG93KDIsIG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4KSxcbiAqICAgLi4ubWV0YWRhdGFcbiAqIH0pXG4gKlxuICogY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKVxuICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gKiAgIG5ldyBQbGFuZUdlb21ldHJ5KCksXG4gKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gKiApXG4gKiBzY2VuZS5hZGQobWVzaClcbiAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gKlxuICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAqIC8vIHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGl0XG4gKiByZXN1bHQuZGlzcG9zZSgpXG4gKlxuICogQHBhcmFtIHBhcmFtc1xuICogQHJldHVybnNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgV2ViR0xSZW5kZXJlciBmYWlscyB0byByZW5kZXIgdGhlIGdhaW4gbWFwXG4gKi9cbmNvbnN0IGRlY29kZSA9IChwYXJhbXMpID0+IHtcbiAgICAvLyBFbnN1cmUgcmVuZGVyZXIgaXMgZGVmaW5lZCBmb3IgdGhlIGJhc2UgZnVuY3Rpb25cbiAgICBpZiAoIXBhcmFtcy5yZW5kZXJlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVyIGlzIHJlcXVpcmVkIGZvciBkZWNvZGUgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcXVhZFJlbmRlcmVyID0gZGVjb2RlSW1wbCh7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgcmVuZGVyZXI6IHBhcmFtcy5yZW5kZXJlclxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIHF1YWRSZW5kZXJlci5yZW5kZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFdlYkdMIGxvYWRlcnNcbiAqIEB0ZW1wbGF0ZSBUVXJsIC0gVGhlIHR5cGUgb2YgVVJMIHVzZWQgdG8gbG9hZCByZXNvdXJjZXNcbiAqL1xuY2xhc3MgTG9hZGVyQmFzZVdlYkdMIGV4dGVuZHMgTG9hZGVyQmFzZVNoYXJlZCB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIG1hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICBjcmVhdGVNYXRlcmlhbDogKHBhcmFtcykgPT4gbmV3IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwocGFyYW1zKSxcbiAgICAgICAgICAgIGNyZWF0ZVF1YWRSZW5kZXJlcjogKHBhcmFtcykgPT4gbmV3IFF1YWRSZW5kZXJlcihwYXJhbXMpXG4gICAgICAgIH0sIG1hbmFnZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBxdWFkUmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gc2RyQnVmZmVyXG4gICAgICogQHBhcmFtIGdhaW5NYXBCdWZmZXJcbiAgICAgKi9cbiAgICBhc3luYyByZW5kZXIocXVhZFJlbmRlcmVyLCBtZXRhZGF0YSwgc2RyQnVmZmVyLCBnYWluTWFwQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2RySW1hZ2UsIGdhaW5NYXBJbWFnZSwgbmVlZHNGbGlwIH0gPSBhd2FpdCB0aGlzLnByb2Nlc3NJbWFnZXMoc2RyQnVmZmVyLCBnYWluTWFwQnVmZmVyLCAnZmxpcFknKTtcbiAgICAgICAgY29uc3QgeyBnYWluTWFwLCBzZHIgfSA9IHRoaXMuY3JlYXRlVGV4dHVyZXMoc2RySW1hZ2UsIGdhaW5NYXBJbWFnZSwgbmVlZHNGbGlwKTtcbiAgICAgICAgdGhpcy51cGRhdGVRdWFkUmVuZGVyZXIocXVhZFJlbmRlcmVyLCBzZHJJbWFnZSwgZ2Fpbk1hcCwgc2RyLCBtZXRhZGF0YSk7XG4gICAgICAgIHF1YWRSZW5kZXJlci5yZW5kZXIoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBUaHJlZS5qcyBMb2FkZXIgZm9yIHRoZSBnYWluIG1hcCBmb3JtYXQuXG4gKlxuICogQGNhdGVnb3J5IExvYWRlcnNcbiAqIEBncm91cCBMb2FkZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEdhaW5NYXBMb2FkZXIgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAqIGltcG9ydCB7XG4gKiAgIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuICogICBNZXNoLFxuICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gKiAgIFBsYW5lR2VvbWV0cnksXG4gKiAgIFNjZW5lLFxuICogICBXZWJHTFJlbmRlcmVyXG4gKiB9IGZyb20gJ3RocmVlJ1xuICpcbiAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICpcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBHYWluTWFwTG9hZGVyKHJlbmRlcmVyKVxuICogICAuc2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyh7IG1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIH0pXG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyhbJ3Nkci5qcGVnJywgJ2dhaW5tYXAuanBlZycsICdtZXRhZGF0YS5qc29uJ10pXG4gKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAqXG4gKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gKiAgIG5ldyBQbGFuZUdlb21ldHJ5KCksXG4gKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gKiApXG4gKiBzY2VuZS5hZGQobWVzaClcbiAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gKlxuICogLy8gU3RhcnRpbmcgZnJvbSB0aHJlZS5qcyByMTU5XG4gKiAvLyBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBjYW5cbiAqIC8vIGFsc28gYmUgdXNlZCBhcyBFcXVpcmVjdGFuZ3VsYXIgc2NlbmUgYmFja2dyb3VuZFxuICogLy9cbiAqIC8vIGl0IHdhcyBwcmV2aW91c2x5IG5lZWRlZCB0byBjb252ZXJ0IGl0XG4gKiAvLyB0byBhIERhdGFUZXh0dXJlIHdpdGggYHJlc3VsdC50b0RhdGFUZXh0dXJlKClgXG4gKiBzY2VuZS5iYWNrZ3JvdW5kID0gcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlXG4gKlxuICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAqIC8vIHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGl0XG4gKiByZXN1bHQuZGlzcG9zZSgpXG4gKlxuICovXG5jbGFzcyBHYWluTWFwTG9hZGVyIGV4dGVuZHMgTG9hZGVyQmFzZVdlYkdMIHtcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGdhaW5tYXAgdXNpbmcgc2VwYXJhdGUgZGF0YVxuICAgICAqICogc2RyIGltYWdlXG4gICAgICogKiBnYWluIG1hcCBpbWFnZVxuICAgICAqICogbWV0YWRhdGEganNvblxuICAgICAqXG4gICAgICogdXNlZnVsIGZvciB3ZWJwIGdhaW4gbWFwc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVybHMgQW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW3Nkci5qcGcsIGdhaW5tYXAuanBnLCBtZXRhZGF0YS5qc29uXVxuICAgICAqIEBwYXJhbSBvbkxvYWQgTG9hZCBjb21wbGV0ZSBjYWxsYmFjaywgd2lsbCByZWNlaXZlIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gb25Qcm9ncmVzcyBQcm9ncmVzcyBjYWxsYmFjaywgd2lsbCByZWNlaXZlIGEgYFByb2dyZXNzRXZlbnRgXG4gICAgICogQHBhcmFtIG9uRXJyb3IgRXJyb3IgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGxvYWQoW3NkclVybCwgZ2Fpbk1hcFVybCwgbWV0YWRhdGFVcmxdLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gdGhpcy5wcmVwYXJlUXVhZFJlbmRlcmVyKCk7XG4gICAgICAgIGxldCBzZHI7XG4gICAgICAgIGxldCBnYWluTWFwO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IGxvYWRDaGVjayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZHIgJiYgZ2Fpbk1hcCAmJiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIHNvbHZlcyAjMTZcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHIsIGdhaW5NYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihzZHJVcmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBvbkxvYWQocXVhZFJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChzZHJVcmwpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNkckxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICBsZXQgc2RyVG90YWwgPSAwO1xuICAgICAgICBsZXQgc2RyTG9hZGVkID0gMDtcbiAgICAgICAgbGV0IGdhaW5NYXBMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGdhaW5NYXBUb3RhbCA9IDA7XG4gICAgICAgIGxldCBnYWluTWFwTG9hZGVkID0gMDtcbiAgICAgICAgbGV0IG1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgIGxldCBtZXRhZGF0YVRvdGFsID0gMDtcbiAgICAgICAgbGV0IG1ldGFkYXRhTG9hZGVkID0gMDtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBzZHJUb3RhbCArIGdhaW5NYXBUb3RhbCArIG1ldGFkYXRhVG90YWw7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gc2RyTG9hZGVkICsgZ2Fpbk1hcExvYWRlZCArIG1ldGFkYXRhTG9hZGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSBzZHJMZW5ndGhDb21wdXRhYmxlICYmIGdhaW5NYXBMZW5ndGhDb21wdXRhYmxlICYmIG1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKG5ldyBQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIHsgbGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQoc2RyVXJsKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChnYWluTWFwVXJsKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChtZXRhZGF0YVVybCk7XG4gICAgICAgIGNvbnN0IHNkckxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgc2RyTG9hZGVyLmxvYWQoc2RyVXJsLCBhc3luYyAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNkciBidWZmZXInKTtcbiAgICAgICAgICAgIHNkciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgc2RyTGVuZ3RoQ29tcHV0YWJsZSA9IGUubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgIHNkckxvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgc2RyVG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihzZHJVcmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2Fpbk1hcExvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIubG9hZChnYWluTWFwVXJsLCBhc3luYyAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdhaW5tYXAgYnVmZmVyJyk7XG4gICAgICAgICAgICBnYWluTWFwID0gYnVmZmVyO1xuICAgICAgICAgICAgYXdhaXQgbG9hZENoZWNrKCk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSA9IGUubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgIGdhaW5NYXBMb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgIGdhaW5NYXBUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgLy8gbWV0YWRhdGFMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdqc29uJylcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLmxvYWQobWV0YWRhdGFVcmwsIGFzeW5jIChqc29uKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRhZGF0YSBzdHJpbmcnKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjaGVjayBvbiBKU09OIGZpbGUgYW5kIHJlbW92ZSB0aGlzIGVzbGludCBkaXNhYmxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIG1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZSA9IGUubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgIG1ldGFkYXRhTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICBtZXRhZGF0YVRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcigpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbiAgICB9XG59XG5cbi8qKlxuICogQSBUaHJlZS5qcyBMb2FkZXIgZm9yIGEgSlBFRyB3aXRoIGVtYmVkZGVkIGdhaW5tYXAgbWV0YWRhdGEuXG4gKlxuICogQGNhdGVnb3J5IExvYWRlcnNcbiAqIEBncm91cCBMb2FkZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEhEUkpQR0xvYWRlciB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICogaW1wb3J0IHtcbiAqICAgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXG4gKiAgIE1lc2gsXG4gKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICogICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAqICAgUGxhbmVHZW9tZXRyeSxcbiAqICAgU2NlbmUsXG4gKiAgIFdlYkdMUmVuZGVyZXJcbiAqIH0gZnJvbSAndGhyZWUnXG4gKlxuICogY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpXG4gKlxuICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAqICAgLnNldFJlbmRlclRhcmdldE9wdGlvbnMoeyBtYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB9KVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAqXG4gKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gKiAgIG5ldyBQbGFuZUdlb21ldHJ5KCksXG4gKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gKiApXG4gKiBzY2VuZS5hZGQobWVzaClcbiAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gKlxuICogLy8gU3RhcnRpbmcgZnJvbSB0aHJlZS5qcyByMTU5XG4gKiAvLyBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBjYW5cbiAqIC8vIGFsc28gYmUgdXNlZCBhcyBFcXVpcmVjdGFuZ3VsYXIgc2NlbmUgYmFja2dyb3VuZFxuICogLy9cbiAqIC8vIGl0IHdhcyBwcmV2aW91c2x5IG5lZWRlZCB0byBjb252ZXJ0IGl0XG4gKiAvLyB0byBhIERhdGFUZXh0dXJlIHdpdGggYHJlc3VsdC50b0RhdGFUZXh0dXJlKClgXG4gKiBzY2VuZS5iYWNrZ3JvdW5kID0gcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlXG4gKlxuICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAqIC8vIHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGl0XG4gKiByZXN1bHQuZGlzcG9zZSgpXG4gKlxuICovXG5jbGFzcyBIRFJKUEdMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlV2ViR0wge1xuICAgIC8qKlxuICAgICAqIExvYWRzIGEgSlBFRyBjb250YWluaW5nIGdhaW4gbWFwIG1ldGFkYXRhXG4gICAgICogUmVuZGVycyBhIG5vcm1hbCBTRFIgaW1hZ2UgaWYgZ2Fpbm1hcCBkYXRhIGlzIG5vdCBmb3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBQYXRoIHRvIGEgSlBFRyBmaWxlIGNvbnRhaW5pbmcgZW1iZWRkZWQgZ2FpbiBtYXAgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gb25Mb2FkIExvYWQgY29tcGxldGUgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgUHJvZ3Jlc3MgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSBhIGBQcm9ncmVzc0V2ZW50YFxuICAgICAqIEBwYXJhbSBvbkVycm9yIEVycm9yIGNhbGxiYWNrXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IHRoaXMucHJlcGFyZVF1YWRSZW5kZXJlcigpO1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgICAgbG9hZGVyLmxvYWQodXJsLCBhc3luYyAoanBlZykgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqcGVnID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnVmZmVyLCByZWNlaXZlZCBbc3RyaW5nXSwgd2FzIGV4cGVjdGluZyBbQXJyYXlCdWZmZXJdJyk7XG4gICAgICAgICAgICBjb25zdCBqcGVnQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoanBlZyk7XG4gICAgICAgICAgICBsZXQgc2RySlBFRztcbiAgICAgICAgICAgIGxldCBnYWluTWFwSlBFRztcbiAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFjdGlvblJlc3VsdCA9IGF3YWl0IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcoanBlZ0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgLy8gZ2FpbiBtYXAgaXMgc3VjY2Vzc2Z1bGx5IHJlY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICBzZHJKUEVHID0gZXh0cmFjdGlvblJlc3VsdC5zZHI7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEpQRUcgPSBleHRyYWN0aW9uUmVzdWx0LmdhaW5NYXA7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBleHRyYWN0aW9uUmVzdWx0Lm1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgdGhlIFNEUiB2ZXJzaW9uIGlmIHRoaXMgaXMgbm90IGEgZ2Fpbm1hcFxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yIHx8IGUgaW5zdGFuY2VvZiBHYWluTWFwTm90Rm91bmRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWx1cmUgdG8gcmVjb25zdHJ1Y3QgYW4gSERSIGltYWdlIGZyb20gJHt1cmx9OiBHYWluIG1hcCBtZXRhZGF0YSBub3QgZm91bmQgaW4gdGhlIGZpbGUsIEhEUkpQR0xvYWRlciB3aWxsIHJlbmRlciB0aGUgU0RSIGpwZWdgKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWluOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1tYTogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEhkcjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiBbMCwgMCwgMF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2RySlBFRyA9IGpwZWdCdWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvbHZlcyAjMTZcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXIocXVhZFJlbmRlcmVyLCBtZXRhZGF0YSwgc2RySlBFRy5idWZmZXIsIGdhaW5NYXBKUEVHPy5idWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25Mb2FkKHF1YWRSZW5kZXJlcik7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwsIEdhaW5NYXBMb2FkZXIsIEdhaW5NYXBOb3RGb3VuZEVycm9yLCBIRFJKUEdMb2FkZXIsIEhEUkpQR0xvYWRlciBhcyBKUEVHUkxvYWRlciwgTG9hZGVyQmFzZVNoYXJlZCwgUXVhZFJlbmRlcmVyLCBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IsIGNyZWF0ZURlY29kZUZ1bmN0aW9uLCBkZWNvZGUsIGV4dHJhY3RHYWlubWFwRnJvbUpQRUcgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\n");

/***/ })

};
;